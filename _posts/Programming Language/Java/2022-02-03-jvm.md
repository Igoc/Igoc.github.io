---
title: "자바 가상 기계(JVM)"

categories: [Programming-Language, Java]
tags: [Java, Java Virtual Machine, JVM]

date: 2022-02-03T22:15:00+09:00
last_modified_at: 2022-02-06T21:28:00+09:00
---

자바 가상 기계(JVM)에 대한 정리
{:.notice--primary}

## JVM이란?

- 자바 바이트 코드를 OS에 맞게 해석하고 실행하는 가상 기계이다.
- 자바 애플리케이션을 클래스 로더(Class Loader)를 통해 읽어서 자바 API와 함께 실행하는 역할을 수행한다.

## JVM의 특징

- 스택 기반의 가상 기계
    - 레지스터 기반으로 동작하는 컴퓨터와 달리 JVM은 스택 기반으로 동작한다.

- 심볼릭 레퍼런스
    - 기본 자료형(Primitive Data Type)을 제외한 모든 자료형을 심볼릭 레퍼런스를 통해 참조한다.

- 가비지 컬렉션
    - 클래스 객체는 사용자에 의해 명시적으로 생성되지만, 더이상 참조하는 곳이 없을 경우 가비지 컬렉션에 의해 자동으로 수집된다.

## JVM 구조

![JVM 구조](https://user-images.githubusercontent.com/22683489/152354448-c740abee-47c6-4331-99b6-38cadb39731d.png){:.align-center}

컴파일된 자바 바이트 코드는 먼저 클래스 로더에 의해 런타임 데이터 영역(Runtime Data Areas)에 로드되어진다. 이후 실행 엔진(Execution Engine)에서 이를 읽어 자바 바이트 코드를 실행한다.

### 클래스 로더

자바는 런타임 단계에서 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는데, 이를 수행하는 것이 바로 JVM의 클래스 로더이다.

#### 클래스 로더의 특징

- 계층 구조
    - 클래스 로더 간에 부모-자식 관계를 이루어 계층 구조로 생성된다.

- 위임 모델
    - 계층 구조를 바탕으로 클래스 로더 간에 로드를 위임하는 구조로 동작한다.
    - 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하여, 상위 클래스 로더에 존재한다면 해당 클래스를 가져다 이용한다.
    - 만약 상위 클래스 로더에 로드하려는 클래스가 없다면, 요청을 받은 클래스 로더에서 클래스를 로드한다.

- 가시성 제한
    - 하위 클래스 로더에서는 상위 클래스 로더를 탐색할 수 있다.
    - 상위 클래스 로더에서는 하위 클래스 로더를 탐색할 수 없다.

- 언로드 불가
    - 클래스 로더는 클래스를 로드할 수는 있지만, 이를 언로드할 수는 없다.
    - 만약 언로드가 필요하다면 현재 클래스 로더를 삭제하고, 아예 새로운 클래스 로더를 생성하는 방법으로 해결할 수 있다.

#### 클래스 로더 동작 방식

각각의 클래스 로더는 로드된 클래스들을 보관하는 네임스페이스를 갖고, 여기에 보관된 FQCN(Fully Qualified Class Name)으로 로드된 클래스를 찾는다. 다만 FQCN이 같더라도 네임스페이스가 다르면 다른 클래스로 간주한다.

#### 클래스 로더 위임 모델

![클래스 로더 위임 모델](https://user-images.githubusercontent.com/22683489/152357358-0e4ecd3a-eb87-4b4d-84d0-35b63d711853.png){:.align-center}

클래스 로더가 로드를 요청받으면 클래스 로더 캐시, 상위 클래스 로더, 자기 자신 순으로 해당 클래스가 있는지 확인한다. 클래스 로더 캐시에도 없고 상위 클래스를 거슬러 올라가 최상위 클래스 로더에도 없으면, 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾는다.

- 부트스트랩 클래스 로더(Bootstrap Class Loader)
    - JVM을 기동할 때 생성되는 최상위 클래스 로더이다.
    - `java.lang.Object` 클래스를 비롯한 자바 API들을 로드한다.
    - 다른 클래스 로더와 달리 자바가 아닌 네이티브 코드로 구현되어 있다.

- 익스텐션 클래스 로더(Extension Class Loader)
    - 보안 확장 기능 등과 같이 기본 자바 API를 제외한 확장 클래스들을 로드한다.

- 시스템 클래스 로더(System Class Loader)
    - 애플리케이션 클래스들을 로드하며, 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.

- 사용자 정의 클래스 로더(User Defined Class Loader)
    - 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더이다.

#### 클래스 로드 단계

![클래스 로드 단계](https://user-images.githubusercontent.com/22683489/152358378-941c3bc4-16f5-4666-8083-d57a409f5687.png){:.align-center}

- 로드(Loading)
    - 클래스를 파일 시스템에서 읽어와서 JVM의 메모리(메서드 영역)에 로드한다.

- 검증(Verifying)
    - 읽은 클래스가 자바 언어 명세와 JVM 명세에 따라 잘 구성되어 있는지 검사한다.

- 준비(Preparing)
    - 클래스가 필요로 하는 메모리를 할당한다.
    - 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.

- 분석(Resoving)
    - 클래스의 상수 풀(Constant Pool) 안의 모든 심볼릭 레퍼런스들을 다이렉트 레퍼런스로 변경한다.

- 초기화 (Initializing)
    - 클래스의 정적 변수들을 적절한 값으로 초기화한다.

### 런타임 데이터 영역

![런타임 데이터 영역](https://user-images.githubusercontent.com/22683489/152359372-f0f98a8b-fdfc-4233-8a58-f3beecb798d7.png){:.align-center}

JVM이 OS로부터 할당받는 메모리 영역으로, 6개의 영역으로 나눌 수 있다.

- PC 레지스터(PC Register)
    - 현재 수행 중인 JVM 명령 주소인 PC(Program Counter)를 저장한다.
    - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.

- JVM 스택(JVM Stack)
    - 스택 프레임이라는 구조체를 저장하는 스택이다.
    - 예외 발생 시 출력 가능한 Stack trace의 각 라인은 하나의 스택 프레임을 표현한다.
    - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.

- 네이티브 메서드 스택(Native Method Stack)
    - 자바 이외의 언어로 작성된 네이티브 코드를 위한 스택이다.
    - JNI(Java Native Interface)를 통해 호출되는 코드를 위한 공간이다.
    - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다.

- 힙(Heap)
    - 객체를 저장하는 공간으로 가비지 컬렉션의 대상이다.

- 메서드 영역(Method Area)
    - 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다.
    - JVM이 읽은 클래스들과 필드와 메서드 정보 등을 보관한다.

- 런타임 상수 풀(Runtime Constant Pool)
    - 각 클래스와 인터페이스 상수, 메서드와 필드에 대한 모든 레퍼런스들을 담고 있는 테이블이다.
    - 클래스마다 상수 풀을 생성하여 실제 대상의 레퍼런스를 보관한다.
    - JVM에서 어떤 메서드나 필드를 참조할 때 런타임 상수 풀을 통해 실제 메모리 주소를 획득한다.

#### JVM 스택 구조

![JVM 스택 구조](https://user-images.githubusercontent.com/22683489/152360172-788db2c8-4dc2-4de0-92a2-6e15aafdc6cc.png){:.align-center}

- 스택 프레임(Stack Frame)
    - JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어, 해당 스레드의 JVM 스택에 추가되고 메서드가 종료되면 제거된다.
    - 각각의 스택 프레임에는 지역 변수 배열, 피연산자 스택, 런타임 상수 풀에 대한 레퍼런스를 갖는다.

- 지역 변수 배열(Local Variable Array)
    - 0번 인덱스는 메서드가 속한 클래스 객체의 this 레퍼런스를 담는다.
    - 1번 인덱스부터는 메서드에 전달된 파라미터들이 저장되며, 이후에는 메서드의 지역 변수들이 저장된다.

- 피연산자 스택(Operand Stack)
    - 메서드의 실제 작업 공간이다.
    - 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 스택에 담거나 꺼낸다.

### 실행 엔진

클래스 로더를 통해 JVM의 런타임 데이터 영역에 배치된 바이트 코드는 실행 엔진에 의해 실행된다. 실행 엔진은 CPU가 기계 명령어를 하나씩 실행하듯이, 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.

#### 인터프리터 방식

바이트 코드 명령어를 하나씩 읽어서 해석하고 실행하는 방식이다. 바이트 코드 각각의 해석은 빠른 대신 결과의 실행은 느리다는 인터프리터 언어의 단점을 그대로 갖는다.

#### JIT(Just-In-Time) 컴파일러 방식

![JIT 컴파일러 방식](https://user-images.githubusercontent.com/22683489/152364019-16089d53-fa2c-4e41-903d-5c77404e7f3a.png){:.align-center}

인터프리터의 단점을 보완하기 위해 도입된 것으로, 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드를 컴파일하여 네이티브 코드로 변경해 실행하는 방식이다. 하지만 적게 실행되는 코드의 경우 인터프리팅하여 실행하는 것이 더 유리하기 때문에, JIT 컴파일러를 사용하는 대부분의 JVM은 해당 메서드가 얼마나 자주 수행되는지를 체크하여 컴파일을 수행한다.